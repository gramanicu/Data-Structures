// Copyright Grama Nicolae 2019
#ifndef HASHTABLE_H_
#define HASHTABLE_H_

/*  This is a implementation of a hashtable. It is implemented
    using an array of "buckets". 

    A hashtable is a implementation of a dictionary, optimized
    for searching (O(1) search time). The hashtable stores pairs
    of keys and values. More details can be found in the methods
    description.
*/

#include <memory.h>
#include <iostream>
#include <list>

#define DSIZE 100       // Default size for the array
#define RLIMIT 75       // Default occupation limit
#define RFACTOR 2       // Default expansion factor (resize factor)

template <typename K, typename V>
class Hashtable {
   private:
    /*
        The search for a value associated to a key is called indexing. This
        is done by "hashing" (using a special function that transforms the key
        into a integer), and using that hash as the index in the array for that
        pair. The problem is that sometimes different keys generate same hash.
        One way to get around this problem is to store the pairs in buckets.
        A bucket is a list of key-value pairs, and the search is done linearly 
        (pair by pair).
    */
    class Bucket {
       public:
        std::list<std::pair<K, V>> values;
        Bucket(){};
        Bucket(const Bucket& other) { values = other.values; }

        V search(const K& key) {
            for (auto& it : values) {
                if (it.first == key) {
                    return it.second;
                }
            }
            return V(NULL);
        }

        void insert(const std::pair<K, V> p) {
            for (auto& it : values) {
                if (it.first == p.first) {
                    it.second = p.second;
                    return;
                }
            }
            values.push_back(p);
        }

        void remove(const K& key) {
            typename std::list<std::pair<K, V>>::iterator it;
            for (it = values.begin(); it != values.end(); ++it) {
                if ((*it).first == key) {
                    values.erase(it);
                    return;
                }
            }
        }
    };


    std::hash<K> hasher;    // The hash function
    /*  Note - to ensure that hash generated by the hash function is a valid index in
               the array of buckets, we apply the "% array_size" on it. So, the actual
               the hash function will change depending on the array size.
    */

    Bucket* table;          // The array of buckets
    int _size;              // The number of values stored
    int hmax;               // The size of the array
    int rLimit;             // The occupation limit before resize (in %)
    float rFactor;          // The resize factor (how many times to increase the array)

    /*
        As we insert more elements in the hashtable, the chance that two keys
        generate the same hash increases. So, to keep the search times minimal,
        the hashtable's array will be increased by some "rFactor" factor. Setting
        the rLimit to 50 and rFactor to 4 will mean that "when the number of 
        elements stored in the hashtable is over 50% the number of buckets, the 
        size of the array will quadruple". Also, when the array size is increased,
        the key-value pairs are redistributed. As it was noted, the new hashes will
        be different, because the hash function automatically changed.
    */

    void checkResize() {
        if (float(_size) / hmax > float(rLimit) / 100) {
            // Create a new, bigger table
            Bucket* aux = new Bucket[int(hmax * rFactor)];

            // Search in every bucket
            for (int i = 0; i < hmax; i++) {
                Bucket curr = aux[i];
                // Insert all elements from the bucket in the new table
                for (auto& i : curr.values) {
                    int id = hasher(i.first) % int(hmax * rFactor);
                    aux[id].insert(i);
                }
            }

            // Delete and replace the old table
            delete[] table;
            table = aux;

            // Update the table size
            hmax = int(hmax * rFactor);
        }
    }

   public:
    // Constructor
    Hashtable(int size = DSIZE, int limit = RLIMIT, float factor = RFACTOR)
        : _size(0), hmax(size), rLimit(limit), rFactor(factor) {
        table = new Bucket[hmax];
    }

    // Copy-Constructor
    Hashtable(const Hashtable& other)
        : _size(other._size),
          hmax(other.hmax),
          rLimit(other.rLimit),
          rFactor(other.rFactor) {
        table = new Bucket[hmax];
        for (int i = 0; i < hmax; i++) {
            table[i] = other.table[i];
        }
    }

    // Destructor
    ~Hashtable() { delete[] table; }

    // Insert a key-value pair in the hashtable
    void put(const K& key, const V& value) {
        int id = hasher(key) % hmax;
        table[id].insert(std::make_pair(key, value));
        _size++;
        checkResize();
    }

    // Remove a key-value pair from the hashtable
    void remove(const K& key) {
        int id = hasher(key) % hmax;
        table[id].remove(key);
        _size--;
    }

    // Get the value associated to a key from the hashtable
    V get(const K& key) {
        int id = hasher(key) % hmax;
        return table[id].search(key);
    }

    // Checks if a key exists in the hashtable
    bool hasKey(const K& key) {
        int id = hasher(key) % hmax;
        return (table[id].search(key) != V(NULL));
    }

    // Returns the number of pairs in the hashtable
    int size() { return _size; }

    // Returns the number of buckets in the hashtable
    int maxSize() { return hmax; }
};

#endif  // HASHTABLE_H_